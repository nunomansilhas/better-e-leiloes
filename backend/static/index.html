<!DOCTYPE html>
<html lang="pt" data-bs-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>E-Leiloes Backend - Admin Tools</title>
    <!-- Bootstrap 5 CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Bootstrap Icons -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css" rel="stylesheet">
    <!-- Google Fonts -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap">
    <!-- Dashboard Styles -->
    <link rel="stylesheet" href="/static/dashboard.css">
</head>
<body>
    <div class="main-container">
        <!-- Header + Stats -->
        <div class="custom-card p-2 mb-3">
            <div class="d-flex align-items-center justify-content-between flex-wrap gap-2">
                <!-- Brand + Health -->
                <div class="d-flex align-items-center gap-3">
                    <h1 class="brand-text h6 mb-0">E-Leiloes</h1>
                    <div class="health-badge" id="health-status" onclick="showHealthDetails()" title="Click para detalhes">
                        <span id="health-dot" class="health-dot offline"></span>
                        <span id="health-text">--</span>
                    </div>
                </div>
                <!-- Main Stats + Sparkline -->
                <div class="d-flex align-items-center gap-2">
                    <div class="stat-box">
                        <span class="stat-value" id="stat-total">-</span>
                        <span class="stat-label">total</span>
                    </div>
                    <div class="stat-box success">
                        <span class="stat-value" id="stat-ativos">-</span>
                        <span class="stat-label">ativos</span>
                    </div>
                    <div class="stat-box danger">
                        <span class="stat-value" id="stat-inativos">-</span>
                        <span class="stat-label">terminados</span>
                    </div>
                    <div class="sparkline-box" title="Atividade (√∫ltimas 24h)">
                        <canvas id="activity-sparkline" width="60" height="24"></canvas>
                        <span class="sparkline-label">atividade</span>
                    </div>
                </div>
            </div>
            <!-- Type Stats Row -->
            <div class="type-row mt-2">
                <div class="type-item" data-tooltip="Im√≥veis">üè† <span id="stat-type-1">-</span></div>
                <div class="type-item" data-tooltip="Ve√≠culos">üöó <span id="stat-type-2">-</span></div>
                <div class="type-item" data-tooltip="Outros Bens">üì¶ <span id="stat-type-3">-</span></div>
                <div class="type-item" data-tooltip="Direitos">‚öñÔ∏è <span id="stat-type-4">-</span></div>
                <div class="type-item" data-tooltip="Unidades Industriais">üè¢ <span id="stat-type-5">-</span></div>
                <div class="type-item" data-tooltip="Outros">üìÑ <span id="stat-type-6">-</span></div>
            </div>
        </div>

        <!-- Scraper Tools -->
        <div class="custom-card p-3 mb-3">
            <div class="d-flex align-items-center justify-content-between">
                <div class="d-flex align-items-center gap-2">
                    <i class="bi bi-tools text-muted"></i>
                    <span class="fw-semibold small">Tools</span>
                </div>
                <div class="d-flex gap-1">
                    <button class="tool-btn blue" onclick="runScraper('ids')" data-tooltip="Descobrir IDs - Scrape todas as p√°ginas para encontrar novos eventos">
                        <i class="bi bi-search"></i>
                    </button>
                    <button class="tool-btn green" onclick="runScraper('content')" data-tooltip="Completar Info - Buscar detalhes dos eventos sem informa√ß√£o">
                        <i class="bi bi-card-text"></i>
                    </button>
                    <button class="tool-btn yellow" onclick="runUpdatePrices()" data-tooltip="Atualizar Pre√ßos - Verificar lance_atual de todos os eventos ativos">
                        <i class="bi bi-currency-euro"></i>
                    </button>
                    <button class="tool-btn purple" onclick="runFixNulls()" data-tooltip="Fix NULLs - Corrigir eventos com campos em falta">
                        <i class="bi bi-wrench"></i>
                    </button>
                    <button class="tool-btn gray" onclick="toggleManualIds()" data-tooltip="IDs Manual - Inserir refer√™ncias espec√≠ficas para processar">
                        <i class="bi bi-input-cursor-text"></i>
                    </button>
                    <span class="tool-divider"></span>
                    <button class="tool-btn red" onclick="confirmClearDatabase()" data-tooltip="Clear DB - Apagar todos os eventos, hist√≥rico e configura√ß√µes">
                        <i class="bi bi-trash3"></i>
                    </button>
                    <button class="tool-btn red" onclick="confirmClearNotifications()" data-tooltip="Clear Notifs - Apagar todas as regras de notifica√ß√£o">
                        <i class="bi bi-bell-slash"></i>
                    </button>
                </div>
            </div>

            <!-- Manual IDs Input -->
            <div id="manual-ids-section" class="mt-2" style="display: none;">
                <div class="d-flex gap-2">
                    <input type="text" class="form-control form-control-sm" id="manual-ids-input" placeholder="LO1234562024, NP9876542024...">
                    <button class="btn btn-outline-purple btn-sm" onclick="runManualIds()">Go</button>
                </div>
            </div>
        </div>

        <!-- Pipelines Automaticas -->
        <div class="custom-card p-3 mb-3">
            <div class="d-flex align-items-center gap-2 mb-2 pb-1 border-bottom border-secondary">
                <i class="bi bi-lightning-charge-fill"></i>
                <h6 class="mb-0 fw-semibold">Pipelines Autom√°ticas</h6>
            </div>
            <div class="row g-2">
                <!-- X-Monitor -->
                <div class="col-12 col-md-4">
                    <div class="pipeline-card" id="card-xmonitor">
                        <div class="d-flex justify-content-between align-items-start mb-2">
                            <div>
                                <div class="d-flex align-items-center gap-2 mb-1">
                                    <span>üî¥</span>
                                    <strong class="small">X-Monitor</strong>
                                    <span id="status-xmonitor" class="pipeline-status" style="display: none;"></span>
                                    <span id="x-monitor-count" class="xmonitor-badge">0</span>
                                </div>
                                <div class="small text-muted">
                                    üî¥ <span id="x-critical">0</span> &nbsp;
                                    üü† <span id="x-urgent">0</span> &nbsp;
                                    üü° <span id="x-soon">0</span>
                                </div>
                            </div>
                            <div class="form-check form-switch">
                                <input class="form-check-input" type="checkbox" id="toggle-xmonitor" onchange="togglePipeline('xmonitor', this.checked)">
                            </div>
                        </div>
                        <div class="pipeline-timer red" id="timer-xmonitor">--:--</div>
                    </div>
                </div>

                <!-- Y-Sync -->
                <div class="col-12 col-md-4">
                    <div class="pipeline-card" id="card-ysync">
                        <div class="d-flex justify-content-between align-items-start mb-2">
                            <div>
                                <div class="d-flex align-items-center gap-2 mb-1">
                                    <span>üîÑ</span>
                                    <strong class="small">Y-Sync</strong>
                                    <span id="status-ysync" class="pipeline-status" style="display: none;"></span>
                                </div>
                                <div class="small text-muted">Sync completo + Terminados</div>
                            </div>
                            <div class="form-check form-switch">
                                <input class="form-check-input" type="checkbox" id="toggle-ysync" onchange="togglePipeline('ysync', this.checked)">
                            </div>
                        </div>
                        <div class="pipeline-timer blue" id="timer-ysync">--:--:--</div>
                    </div>
                </div>

                <!-- Z-Watch -->
                <div class="col-12 col-md-4">
                    <div class="pipeline-card" id="card-zwatch">
                        <div class="d-flex justify-content-between align-items-start mb-2">
                            <div>
                                <div class="d-flex align-items-center gap-2 mb-1">
                                    <span>üëÅÔ∏è</span>
                                    <strong class="small">Z-Watch</strong>
                                    <span id="status-zwatch" class="pipeline-status" style="display: none;"></span>
                                </div>
                                <div class="small text-muted">Novos eventos (10min)</div>
                            </div>
                            <div class="form-check form-switch">
                                <input class="form-check-input" type="checkbox" id="toggle-zwatch" onchange="togglePipeline('zwatch', this.checked)">
                            </div>
                        </div>
                        <div class="pipeline-timer green" id="timer-zwatch">--:--</div>
                    </div>
                </div>

                <!-- Refresh Stats -->
                <div class="col-12 col-md-4">
                    <div class="pipeline-card">
                        <div class="d-flex justify-content-between align-items-center">
                            <div class="d-flex align-items-center gap-1">
                                <span style="font-size: 0.7rem;">üîÑ</span>
                                <strong class="small">Refresh</strong>
                                <span id="refresh-pending-badge" class="badge bg-warning text-dark" style="font-size: 0.5rem; display: none;">0</span>
                            </div>
                            <div class="d-flex align-items-center gap-2">
                                <div class="text-center">
                                    <div style="font-size: 0.9rem; font-weight: 700; color: #10b981;" id="refresh-count-24h">0</div>
                                    <div style="font-size: 0.5rem; color: #64748b;">24h</div>
                                </div>
                                <div class="text-center">
                                    <div style="font-size: 0.75rem; font-weight: 600; color: #94a3b8;" id="refresh-count-all">0</div>
                                    <div style="font-size: 0.5rem; color: #64748b;">total</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Pipeline API -->
        <div class="custom-card p-3 mb-3">
            <div class="d-flex align-items-center gap-2 mb-2 pb-1 border-bottom border-secondary">
                <i class="bi bi-rocket-takeoff-fill"></i>
                <h6 class="mb-0 fw-semibold">Pipeline API</h6>
            </div>
            <div class="d-flex flex-column flex-sm-row align-items-center gap-3">
                <div class="d-flex align-items-center gap-2 flex-grow-1 small">
                    <div id="stage1-dot" class="stage-dot inactive">1</div>
                    <span>IDs <span id="stage1-count" class="text-muted"></span></span>
                    <div class="flex-grow-1 mx-2" style="height: 2px; background: rgba(255,255,255,0.1);"></div>
                    <div id="stage2-dot" class="stage-dot inactive">2</div>
                    <span>API <span id="stage2-count" class="text-muted"></span></span>
                </div>
                <button class="btn btn-outline-blue" id="btn-pipeline" onclick="runApiPipeline()">
                    <i class="bi bi-play-fill"></i> Run
                </button>
            </div>

            <!-- Feedback Box -->
            <div class="feedback-box mt-3 p-3" id="pipeline-feedback" style="display: none;">
                <div class="small text-muted mb-1" id="feedback-stage">Stage 1</div>
                <div class="d-flex justify-content-between align-items-center small mb-2">
                    <span id="feedback-status">A processar...</span>
                    <span id="feedback-count" class="text-primary fw-semibold">0/0</span>
                </div>
                <div class="progress progress-thin">
                    <div class="progress-bar" id="feedback-progress" style="width: 0%;"></div>
                </div>
            </div>
        </div>

    </div>

    <!-- Toast Container -->
    <div class="toast-container" id="toast-container"></div>

    <!-- Keyboard Shortcuts Hint -->
    <div class="shortcuts-hint">
        <kbd>R</kbd>Refresh <kbd>P</kbd>Pipeline <kbd>?</kbd>Help
    </div>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>

    <script>
        const API_BASE = window.location.origin;
        let pipelineRunning = false;
        let pipelinePollingInterval = null;

        // Pipeline timers - stored locally for smooth countdown
        const pipelineTimers = {
            xmonitor: null,  // Date object for next_run
            ysync: null,
            zwatch: null
        };

        // ============== AUTH ==============
        const ApiAuth = {
            key: localStorage.getItem('api_auth_key') || '',

            async generateSignature(method, path, body = '') {
                if (!this.key) return null;
                const timestamp = Math.floor(Date.now() / 1000).toString();
                const message = `${method}:${path}:${timestamp}:${body}`;
                const encoder = new TextEncoder();
                const keyData = encoder.encode(this.key);
                const messageData = encoder.encode(message);
                const cryptoKey = await crypto.subtle.importKey('raw', keyData, { name: 'HMAC', hash: 'SHA-256' }, false, ['sign']);
                const signature = await crypto.subtle.sign('HMAC', cryptoKey, messageData);
                const signatureHex = Array.from(new Uint8Array(signature)).map(b => b.toString(16).padStart(2, '0')).join('');
                return { signature: signatureHex, timestamp };
            }
        };

        async function authFetch(url, options = {}) {
            const method = options.method || 'GET';
            const urlPath = new URL(url, window.location.origin).pathname;
            const body = options.body || '';
            const auth = await ApiAuth.generateSignature(method, urlPath, body);

            const headers = { ...options.headers };
            if (auth) {
                headers['X-Signature'] = auth.signature;
                headers['X-Timestamp'] = auth.timestamp;
            }

            const response = await fetch(url, { ...options, headers });
            if (!response.ok) {
                const data = await response.json().catch(() => ({}));
                throw new Error(data.detail || `HTTP ${response.status}`);
            }
            return response;
        }

        // ============== SECURITY: HTML ESCAPE ==============
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // ============== TOAST NOTIFICATIONS ==============
        function showToast(message, type = 'info', duration = 4000) {
            const container = document.getElementById('toast-container');
            const icons = {
                success: 'bi-check-circle-fill',
                error: 'bi-x-circle-fill',
                warning: 'bi-exclamation-triangle-fill',
                info: 'bi-info-circle-fill'
            };
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            // SECURITY: Escape message to prevent XSS
            const safeMessage = escapeHtml(message);
            toast.innerHTML = `
                <i class="bi ${icons[type] || icons.info}"></i>
                <span>${safeMessage}</span>
                <span class="toast-close" onclick="this.parentElement.remove()">√ó</span>
            `;
            container.appendChild(toast);
            setTimeout(() => {
                toast.classList.add('hiding');
                setTimeout(() => toast.remove(), 300);
            }, duration);
        }

        // Log function now shows toasts for important messages
        function addLog(message, type = 'info') {
            // Map log types to toast types
            const typeMap = { 'success': 'success', 'warning': 'warning', 'error': 'error' };
            // Only show toasts for important events (success, warning, error)
            if (typeMap[type]) {
                showToast(message.replace(/[üîçüìÑüí∂üîß‚å®Ô∏è‚úÖ‚ùå‚ö†Ô∏èüóëÔ∏èüîîüöÄüõëüîÑüëÅÔ∏èüî¥üü†üü°]/g, '').trim(), typeMap[type]);
            }
        }

        // ============== KEYBOARD SHORTCUTS ==============
        document.addEventListener('keydown', (e) => {
            // Ignore if typing in input
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

            switch(e.key.toLowerCase()) {
                case 'r':
                    refreshStats();
                    loadPipelinesStatus();
                    showToast('Dados atualizados', 'info', 2000);
                    break;
                case 'p':
                    document.getElementById('btn-pipeline').click();
                    break;
                case '?':
                    showToast('R=Refresh P=Pipeline ?=Help', 'info', 3000);
                    break;
                case 'escape':
                    // Close any open modals
                    const modal = document.getElementById('confirm-modal');
                    if (modal) modal.remove();
                    break;
            }
        });

        // ============== SPARKLINE CHART ==============
        const activityData = new Array(12).fill(0); // 12 data points for activity

        function drawSparkline(canvasId, data, color = '#3b82f6') {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;

            ctx.clearRect(0, 0, w, h);

            if (!data || data.length === 0) return;

            const max = Math.max(...data, 1);
            const min = Math.min(...data, 0);
            const range = max - min || 1;
            const step = w / (data.length - 1 || 1);

            // Draw gradient fill
            const gradient = ctx.createLinearGradient(0, 0, 0, h);
            gradient.addColorStop(0, color + '40');
            gradient.addColorStop(1, color + '00');

            ctx.beginPath();
            ctx.moveTo(0, h);
            data.forEach((val, i) => {
                const x = i * step;
                const y = h - ((val - min) / range) * (h - 4) - 2;
                if (i === 0) ctx.lineTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.lineTo(w, h);
            ctx.fillStyle = gradient;
            ctx.fill();

            // Draw line
            ctx.beginPath();
            data.forEach((val, i) => {
                const x = i * step;
                const y = h - ((val - min) / range) * (h - 4) - 2;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.strokeStyle = color;
            ctx.lineWidth = 1.5;
            ctx.stroke();

            // Draw end dot
            const lastX = (data.length - 1) * step;
            const lastY = h - ((data[data.length - 1] - min) / range) * (h - 4) - 2;
            ctx.beginPath();
            ctx.arc(lastX, lastY, 2, 0, Math.PI * 2);
            ctx.fillStyle = color;
            ctx.fill();
        }

        function updateActivitySparkline() {
            // Shift data and add new random activity (simulated)
            activityData.shift();
            activityData.push(Math.random() * 10 + (activityData[activityData.length - 1] || 5) * 0.3);
            drawSparkline('activity-sparkline', activityData, '#3b82f6');
        }

        // Initialize sparkline
        setTimeout(() => {
            // Initial random data
            for (let i = 0; i < activityData.length; i++) {
                activityData[i] = Math.random() * 8 + 2;
            }
            drawSparkline('activity-sparkline', activityData, '#3b82f6');
        }, 100);

        // Update sparkline every 5 seconds
        setInterval(updateActivitySparkline, 5000);

        // ============== STATS ==============
        async function refreshStats(silent = false) {
            try {
                const response = await fetch(`${API_BASE}/api/db/stats`);
                const data = await response.json();
                document.getElementById('stat-total').textContent = data.total || 0;
                document.getElementById('stat-ativos').textContent = data.ativos || 0;
                document.getElementById('stat-inativos').textContent = data.inativos || 0;

                // Stats por tipo
                const byType = data.by_type || {};
                for (let i = 1; i <= 6; i++) {
                    const el = document.getElementById(`stat-type-${i}`);
                    if (el) el.textContent = byType[i] || 0;
                }
            } catch (e) {
                console.error('Error loading stats:', e);
            }
        }

        // ============== SCRAPERS ==============
        async function runScraper(type) {
            try {
                addLog(`‚ñ∂ A executar scraper: ${type.toUpperCase()}`, 'info');

                let url, message;
                if (type === 'ids') {
                    url = `${API_BASE}/api/scrape/stage1/ids`;
                    message = 'A descobrir IDs...';
                } else if (type === 'content') {
                    const refs = await fetch(`${API_BASE}/api/events?limit=100000`);
                    const data = await refs.json();
                    const references = data.events.map(e => e.reference);
                    if (references.length === 0) {
                        addLog('Nenhum evento na BD', 'warning');
                        return;
                    }
                    url = `${API_BASE}/api/scrape/stage2/details?save_to_db=true&` + references.map(r => `references=${encodeURIComponent(r)}`).join('&');
                    message = `A completar info de ${references.length} eventos...`;
                }

                addLog(message, 'info');
                startPolling();

                const response = await authFetch(url, { method: 'POST' });
                const result = await response.json();

                addLog(`‚úÖ ${type.toUpperCase()}: ${result.message || 'Concluido!'}`, 'success');
                refreshStats();
            } catch (e) {
                addLog(`‚ùå Erro: ${e.message}`, 'error');
            }
        }

        async function runUpdatePrices() {
            if (!confirm('Atualizar pre√ßos de todos os eventos?')) return;
            try {
                addLog('üí∞ A atualizar pre√ßos...', 'info');
                const response = await authFetch(`${API_BASE}/api/db/update-prices`, { method: 'POST' });
                const data = await response.json();
                addLog(`‚úÖ ${data.message}`, 'success');
                refreshStats();
            } catch (e) {
                addLog(`‚ùå Erro: ${e.message}`, 'error');
            }
        }

        async function runFixNulls() {
            if (!confirm('Corrigir valores NULL?')) return;
            try {
                addLog('üîß A corrigir NULLs...', 'info');
                const response = await authFetch(`${API_BASE}/api/db/fix-nulls`, { method: 'POST' });
                const data = await response.json();
                addLog(`‚úÖ ${data.fixed} valores corrigidos`, 'success');
                refreshStats();
            } catch (e) {
                addLog(`‚ùå Erro: ${e.message}`, 'error');
            }
        }

        function toggleManualIds() {
            const section = document.getElementById('manual-ids-section');
            section.style.display = section.style.display === 'none' ? 'block' : 'none';
        }

        async function runManualIds() {
            const input = document.getElementById('manual-ids-input').value;
            const ids = input.split(/[,\s\n]+/).map(s => s.trim()).filter(s => s);
            if (ids.length === 0) {
                addLog('Insira pelo menos um ID', 'warning');
                return;
            }
            addLog(`üéØ A processar ${ids.length} IDs...`, 'info');
            // TODO: implement
        }

        // ============== PIPELINES ==============
        async function togglePipeline(type, enabled) {
            try {
                const response = await authFetch(`${API_BASE}/api/auto-pipelines/${type}/toggle?enabled=${enabled}`, {
                    method: 'POST'
                });
                const data = await response.json();
                addLog(`${enabled ? '‚ñ∂' : '‚èπ'} ${type}: ${data.message}`, enabled ? 'success' : 'warning');
                await loadPipelinesStatus();
            } catch (e) {
                addLog(`‚ùå Erro: ${e.message}`, 'error');
                document.getElementById(`toggle-${type}`).checked = !enabled;
            }
        }

        async function loadPipelinesStatus() {
            try {
                const response = await fetch(`${API_BASE}/api/auto-pipelines/status`);
                const data = await response.json();
                const pipelines = data.pipelines || {};

                if (!window._pipelinesLoaded) {
                    console.log('Pipeline states loaded:', Object.fromEntries(
                        Object.entries(pipelines).map(([k, v]) => [k, v.enabled])
                    ));
                    window._pipelinesLoaded = true;
                }

                for (const [type, info] of Object.entries(pipelines)) {
                    const toggle = document.getElementById(`toggle-${type}`);
                    if (toggle) {
                        toggle.checked = info.enabled === true;
                    }

                    // Store next_run timestamp for smooth countdown
                    if (info.next_run) {
                        pipelineTimers[type] = new Date(info.next_run);
                    } else {
                        pipelineTimers[type] = null;
                        // Immediately update timer display when disabled/no next_run
                        const timer = document.getElementById(`timer-${type}`);
                        if (timer) {
                            timer.textContent = type === 'ysync' ? '--:--:--' : '--:--';
                        }
                    }
                }

                if (data.xmonitor_stats) {
                    const counts = data.xmonitor_stats;
                    document.getElementById('x-critical').textContent = counts.critical || 0;
                    document.getElementById('x-urgent').textContent = counts.urgent || 0;
                    document.getElementById('x-soon').textContent = counts.soon || 0;
                    document.getElementById('x-monitor-count').textContent = counts.total || 0;
                }

                const heavyRunning = data.heavy_pipeline_running;
                const heavyWaiting = data.heavy_pipeline_waiting || [];

                const pipelineNameMap = {
                    'Y-Sync': 'ysync',
                    'Z-Watch': 'zwatch',
                    'Pipeline API': 'api'
                };

                ['xmonitor', 'ysync', 'zwatch'].forEach(type => {
                    const statusEl = document.getElementById(`status-${type}`);
                    const cardEl = document.getElementById(`card-${type}`);
                    if (statusEl) {
                        statusEl.style.display = 'none';
                        statusEl.className = 'pipeline-status';
                    }
                    if (cardEl) {
                        cardEl.classList.remove('running');
                    }
                });

                if (pipelines.xmonitor && pipelines.xmonitor.is_running) {
                    const statusEl = document.getElementById('status-xmonitor');
                    const cardEl = document.getElementById('card-xmonitor');
                    if (statusEl) {
                        statusEl.textContent = 'A correr...';
                        statusEl.className = 'pipeline-status running';
                        statusEl.style.display = 'inline-block';
                    }
                    if (cardEl) {
                        cardEl.classList.add('running');
                    }
                }

                if (heavyRunning) {
                    const runningType = pipelineNameMap[heavyRunning];
                    if (runningType && runningType !== 'api') {
                        const statusEl = document.getElementById(`status-${runningType}`);
                        const cardEl = document.getElementById(`card-${runningType}`);
                        if (statusEl) {
                            statusEl.textContent = 'A correr...';
                            statusEl.className = 'pipeline-status running';
                            statusEl.style.display = 'inline-block';
                        }
                        if (cardEl) {
                            cardEl.classList.add('running');
                        }
                    }
                }

                heavyWaiting.forEach(name => {
                    const waitingType = pipelineNameMap[name];
                    if (waitingType && waitingType !== 'api') {
                        const statusEl = document.getElementById(`status-${waitingType}`);
                        if (statusEl) {
                            statusEl.textContent = 'Em fila';
                            statusEl.className = 'pipeline-status waiting';
                            statusEl.style.display = 'inline-block';
                        }
                    }
                });

                const pipelineBtn = document.getElementById('btn-pipeline');
                if (heavyRunning && heavyRunning !== 'Pipeline API' && !pipelineRunning) {
                    pipelineBtn.innerHTML = `<i class="bi bi-pause-fill"></i> ${heavyRunning}`;
                    pipelineBtn.disabled = true;
                } else if (!pipelineRunning) {
                    pipelineBtn.innerHTML = '<i class="bi bi-play-fill"></i> Run';
                    pipelineBtn.disabled = false;
                }
            } catch (e) {
                console.error('Error loading pipelines:', e);
            }
        }

        // Update timer display every second (smooth countdown)
        let timerRefreshPending = false;
        function updateTimersDisplay() {
            const now = new Date();
            let needsRefresh = false;

            for (const [type, nextRun] of Object.entries(pipelineTimers)) {
                const timer = document.getElementById(`timer-${type}`);
                if (!timer) continue;

                if (!nextRun) {
                    timer.textContent = '--:--';
                    continue;
                }

                const secs = Math.floor((nextRun - now) / 1000);

                // If timer hit 0 or went negative, mark for refresh
                if (secs <= 0) {
                    timer.textContent = '0:00';
                    needsRefresh = true;
                    continue;
                }

                if (type === 'ysync') {
                    const h = Math.floor(secs / 3600);
                    const m = Math.floor((secs % 3600) / 60);
                    const s = secs % 60;
                    timer.textContent = `${h}:${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
                } else {
                    const m = Math.floor(secs / 60);
                    const s = secs % 60;
                    timer.textContent = `${m}:${String(s).padStart(2,'0')}`;
                }
            }

            // Refresh pipeline status when any timer hits 0
            if (needsRefresh && !timerRefreshPending) {
                timerRefreshPending = true;
                setTimeout(() => {
                    loadPipelinesStatus();
                    timerRefreshPending = false;
                }, 2000); // Wait 2s for backend to update
            }
        }

        // ============== API PIPELINE ==============
        async function runApiPipeline() {
            const btn = document.getElementById('btn-pipeline');

            if (pipelineRunning) {
                try {
                    await fetch(`${API_BASE}/api/pipeline/kill`, { method: 'POST' });
                    addLog('üõë Pipeline terminada', 'warning');
                } catch (e) {
                    addLog(`Erro ao parar: ${e.message}`, 'error');
                }
                pipelineRunning = false;
                btn.innerHTML = '<i class="bi bi-play-fill"></i> Run';
                btn.className = 'btn btn-outline-blue';
                document.getElementById('pipeline-feedback').style.display = 'none';
                stopPolling();
                return;
            }

            try {
                pipelineRunning = true;
                btn.innerHTML = '<i class="bi bi-stop-fill"></i> Stop';
                btn.className = 'btn btn-outline-red';

                addLog('üöÄ Pipeline API iniciada...', 'info');
                document.getElementById('pipeline-feedback').style.display = 'block';
                updateFeedback('A iniciar...', 'A preparar pipeline...', 0, 0);

                startPolling();

                const response = await authFetch(`${API_BASE}/api/pipeline/api`, { method: 'POST' });
                const data = await response.json();

                if (data.error) {
                    throw new Error(data.error);
                }

                addLog(`‚úÖ ${data.message}`, 'info');

            } catch (e) {
                addLog(`‚ùå Erro: ${e.message}`, 'error');
                pipelineRunning = false;
                btn.innerHTML = '<i class="bi bi-play-fill"></i> Run';
                btn.className = 'btn btn-outline-blue';
                document.getElementById('pipeline-feedback').style.display = 'none';
                stopPolling();
            }
        }

        function updateFeedback(stageName, message, current, total) {
            document.getElementById('feedback-stage').textContent = stageName || 'A processar...';
            document.getElementById('feedback-status').textContent = message || 'A processar...';
            document.getElementById('feedback-count').textContent = `${current} / ${total}`;
            document.getElementById('feedback-progress').style.width = total > 0 ? `${(current/total)*100}%` : '0%';
        }

        // ============== POLLING ==============
        function startPolling() {
            if (pipelinePollingInterval) return;
            pipelinePollingInterval = setInterval(async () => {
                try {
                    const response = await fetch(`${API_BASE}/api/pipeline/status`);
                    const state = await response.json();

                    if (state.active) {
                        const stage = state.stage || 1;
                        const current = state.current || 0;
                        const total = state.total || 0;
                        const stageName = state.stage_name || `Stage ${stage}`;
                        const message = state.message || 'A processar...';

                        updateFeedback(stageName, message, current, total);

                        document.getElementById('stage1-dot').className = `stage-dot ${stage >= 1 ? 'active' : 'inactive'}`;
                        document.getElementById('stage2-dot').className = `stage-dot ${stage >= 2 ? 'active' : 'inactive'}`;
                    } else if (pipelineRunning) {
                        pipelineRunning = false;
                        document.getElementById('btn-pipeline').innerHTML = '<i class="bi bi-play-fill"></i> Run';
                        document.getElementById('btn-pipeline').className = 'btn btn-outline-blue';
                        document.getElementById('pipeline-feedback').style.display = 'none';
                        document.getElementById('stage1-dot').className = 'stage-dot inactive';
                        document.getElementById('stage2-dot').className = 'stage-dot inactive';
                        addLog('‚úÖ Pipeline conclu√≠da!', 'success');
                        refreshStats();
                        stopPolling();
                    }
                } catch (e) {
                    console.error('Polling error:', e);
                }
            }, 500);
        }

        function stopPolling() {
            if (pipelinePollingInterval) {
                clearInterval(pipelinePollingInterval);
                pipelinePollingInterval = null;
            }
        }

        // ============== DANGER ZONE ==============
        function showConfirmModal(title, message, onConfirm) {
            const modal = document.createElement('div');
            modal.id = 'confirm-modal';
            modal.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.6);display:flex;align-items:center;justify-content:center;z-index:99999;backdrop-filter:blur(4px);';
            modal.innerHTML = `
                <div style="background:#1e293b;border-radius:12px;padding:24px;max-width:380px;width:90%;border:1px solid rgba(239,68,68,0.3);box-shadow:0 20px 50px rgba(0,0,0,0.5);">
                    <div style="display:flex;align-items:center;gap:12px;margin-bottom:16px;">
                        <div style="width:40px;height:40px;background:rgba(239,68,68,0.15);border-radius:10px;display:flex;align-items:center;justify-content:center;">
                            <svg width="20" height="20" fill="none" stroke="#ef4444" stroke-width="2" viewBox="0 0 24 24"><path d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"/></svg>
                        </div>
                        <div>
                            <div style="font-weight:600;color:#f1f5f9;font-size:15px;">${escapeHtml(title)}</div>
                            <div style="font-size:12px;color:#94a3b8;">${escapeHtml(message)}</div>
                        </div>
                    </div>
                    <div style="display:flex;gap:10px;justify-content:flex-end;">
                        <button onclick="this.closest('#confirm-modal').remove()" style="padding:8px 16px;background:#334155;border:none;border-radius:6px;color:#e2e8f0;font-size:13px;cursor:pointer;">Cancelar</button>
                        <button id="confirm-btn" style="padding:8px 16px;background:#dc2626;border:none;border-radius:6px;color:white;font-size:13px;font-weight:500;cursor:pointer;">Confirmar</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
            modal.querySelector('#confirm-btn').onclick = () => { modal.remove(); onConfirm(); };
            modal.onclick = (e) => { if (e.target === modal) modal.remove(); };
        }

        function confirmClearDatabase() {
            showConfirmModal(
                'Limpar Base de Dados',
                'Apagar eventos, hist√≥rico, notifica√ß√µes, pipelines e refresh logs?',
                async () => {
                    try {
                        addLog('üóëÔ∏è A apagar tudo...', 'warning');
                        const response = await authFetch(`${API_BASE}/api/database`, { method: 'DELETE' });
                        const data = await response.json();
                        const d = data.deleted || {};
                        addLog(`‚úÖ Apagados: ${d.events||0} eventos, ${d.price_history||0} pre√ßos, ${d.notifications||0} notifs, ${d.refresh_logs||0} refresh, ${d.pipeline_states||0} pipelines`, 'success');
                        // Refresh page after 1 second to show success message
                        setTimeout(() => location.reload(), 1000);
                    } catch (e) {
                        addLog(`‚ùå Erro: ${e.message}`, 'error');
                    }
                }
            );
        }

        function confirmClearNotifications() {
            showConfirmModal(
                'Limpar Notifica√ß√µes',
                'Apagar todas as regras de notifica√ß√£o?',
                async () => {
                    try {
                        addLog('üîî A apagar notifica√ß√µes...', 'warning');
                        const response = await authFetch(`${API_BASE}/api/notifications/delete-all`, { method: 'DELETE' });
                        addLog('‚úÖ Notifica√ß√µes apagadas', 'success');
                    } catch (e) {
                        addLog(`‚ùå Erro: ${e.message}`, 'error');
                    }
                }
            );
        }

        // ============== HEALTH CHECK ==============
        let lastHealthData = null;

        async function checkHealth() {
            try {
                const response = await fetch(`${API_BASE}/api/health`);
                const data = await response.json();
                lastHealthData = data;

                const dot = document.getElementById('health-dot');
                const text = document.getElementById('health-text');

                dot.className = 'health-dot';
                if (data.status === 'healthy') {
                    dot.classList.add('healthy');
                    text.textContent = 'healthy';
                } else if (data.status === 'degraded') {
                    dot.classList.add('degraded');
                    text.textContent = 'degraded';
                } else {
                    dot.classList.add('unhealthy');
                    text.textContent = 'unhealthy';
                }
            } catch (e) {
                document.getElementById('health-dot').className = 'health-dot offline';
                document.getElementById('health-text').textContent = 'offline';
            }
        }

        function showHealthDetails() {
            if (!lastHealthData) return;
            const services = lastHealthData.services || {};
            let msg = `Status: ${lastHealthData.status}\n\n`;
            for (const [name, info] of Object.entries(services)) {
                msg += `${name}: ${info.status}`;
                if (info.error) msg += ` (${info.error})`;
                if (info.active !== undefined) msg += ` (${info.active}/${info.total} active)`;
                msg += '\n';
            }
            alert(msg);
        }

        // ============== CHECK PIPELINE STATE ON LOAD ==============
        async function checkPipelineStateOnLoad() {
            try {
                const response = await fetch(`${API_BASE}/api/pipeline/status`);
                const state = await response.json();

                if (state.active) {
                    pipelineRunning = true;
                    const btn = document.getElementById('btn-pipeline');
                    btn.innerHTML = '<i class="bi bi-stop-fill"></i> Stop';
                    btn.className = 'btn btn-outline-red';
                    btn.disabled = false;

                    document.getElementById('pipeline-feedback').style.display = 'block';
                    const stage = state.stage || 1;
                    const current = state.current || 0;
                    const total = state.total || 0;
                    const stageName = state.stage_name || `Stage ${stage}`;
                    const message = state.message || 'A processar...';
                    updateFeedback(stageName, message, current, total);

                    document.getElementById('stage1-dot').className = `stage-dot ${stage >= 1 ? 'active' : 'inactive'}`;
                    document.getElementById('stage2-dot').className = `stage-dot ${stage >= 2 ? 'active' : 'inactive'}`;

                    startPolling();
                    console.log('üîÑ Pipeline API em execu√ß√£o - estado restaurado');
                }
            } catch (e) {
                console.error('Error checking pipeline state:', e);
            }
        }

        // Load refresh stats
        async function loadRefreshStats() {
            try {
                const response = await fetch(`${API_BASE}/api/refresh/stats`);
                if (response.ok) {
                    const data = await response.json();
                    const el24h = document.getElementById('refresh-count-24h');
                    const elAll = document.getElementById('refresh-count-all');
                    const elPending = document.getElementById('refresh-pending-badge');

                    if (el24h) el24h.textContent = data.total_24h || 0;
                    if (elAll) elAll.textContent = data.total_all_time || 0;

                    // Show/hide pending badge
                    if (elPending) {
                        const pending = data.pending || 0;
                        if (pending > 0) {
                            elPending.textContent = `${pending} pending`;
                            elPending.style.display = 'inline';
                        } else {
                            elPending.style.display = 'none';
                        }
                    }
                }
            } catch (e) {
                console.error('Error loading refresh stats:', e);
            }
        }

        // ============== INIT ==============
        document.addEventListener('DOMContentLoaded', () => {
            addLog('Sistema iniciado', 'success');
            refreshStats(true);
            loadPipelinesStatus();
            loadRefreshStats();
            checkHealth();
            checkPipelineStateOnLoad();

            // Smooth countdown - update display every 1 second
            setInterval(updateTimersDisplay, 1000);

            // Sync with backend
            setInterval(loadPipelinesStatus, 30000);
            setInterval(loadRefreshStats, 5000);

            setInterval(() => refreshStats(true), 10000);
            setInterval(checkHealth, 30000);

            // Mobile: Pull to refresh
            let touchStartY = 0;
            let isPulling = false;
            const ptrIndicator = document.getElementById('ptr-indicator');

            document.addEventListener('touchstart', (e) => {
                if (window.scrollY === 0) {
                    touchStartY = e.touches[0].clientY;
                }
            }, { passive: true });

            document.addEventListener('touchmove', (e) => {
                if (touchStartY > 0 && window.scrollY === 0) {
                    const touchY = e.touches[0].clientY;
                    const diff = touchY - touchStartY;
                    if (diff > 60 && !isPulling) {
                        isPulling = true;
                        ptrIndicator?.classList.add('visible');
                    }
                }
            }, { passive: true });

            document.addEventListener('touchend', () => {
                if (isPulling) {
                    isPulling = false;
                    refreshStats(true);
                    loadPipelinesStatus();
                    checkHealth();
                    setTimeout(() => ptrIndicator?.classList.remove('visible'), 1000);
                }
                touchStartY = 0;
            }, { passive: true });

            // Mobile nav active state
            document.querySelectorAll('.mobile-nav-item').forEach(item => {
                item.addEventListener('click', function(e) {
                    document.querySelectorAll('.mobile-nav-item').forEach(i => i.classList.remove('active'));
                    this.classList.add('active');
                });
            });
        });
    </script>

    <!-- Pull to refresh indicator -->
    <div id="ptr-indicator" class="ptr-indicator">
        <i class="bi bi-arrow-clockwise"></i>
        A atualizar...
    </div>

    <!-- Mobile Bottom Navigation -->
    <nav class="mobile-nav">
        <a href="#" class="mobile-nav-item active" onclick="scrollTo(0,0);return false;">
            <i class="bi bi-house"></i>
            <span>In√≠cio</span>
        </a>
        <a href="#pipelines" class="mobile-nav-item" onclick="document.getElementById('pipelines')?.scrollIntoView({behavior:'smooth'});return false;">
            <i class="bi bi-play-circle"></i>
            <span>Pipelines</span>
        </a>
        <a href="#" class="mobile-nav-item" onclick="refreshStats(true);showToast('Stats atualizados','success');return false;">
            <i class="bi bi-arrow-clockwise"></i>
            <span>Refresh</span>
        </a>
        <a href="#console" class="mobile-nav-item" onclick="document.getElementById('console')?.scrollIntoView({behavior:'smooth'});return false;">
            <i class="bi bi-terminal"></i>
            <span>Console</span>
        </a>
    </nav>
</body>
</html>
